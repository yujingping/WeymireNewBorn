using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using PixelCrushers.DialogueSystem;

public class AnalyzeSystem : MonoBehaviour 
{
	//AnalyzeSystem is also a singleton! This script includes both VIEW and PRESENTOR Section. However their logics are seperated. 
	//Never violate the rules of MVP!!
	private static AnalyzeSystem instance;

	public enum ContentType
	{
		Reminder,
		Conclusion,
		Truth
	}

	private enum AnalyzeResult
	{
		Success = 0,
		NeedMore = 1,
		Irrelevant = 2,
		Contradictive = 3,
		Empty = 4,
	}

	public struct Content
	{
		public ContentType type;
		public int index;
		public string title;
		public string content;
		public int another; // For truths, this value is -1 by default. After all truths cannot be composited any more ... 
		public int another2; //To meet the strange requirements from JiaWen. But why should some conclusions be generated by three reminders?
		public int higher; //This is the corresponding higher-level content. Truths have -1 for this variable.

		public Content (ContentType ty, string t, string c, int i, int a = -1, int a2 = -1, int h = -1)
		{
			type = ty;
			title = t;
			content = c;
			index = i;
			another = a;
			another2 = a2;
			higher = h;
		}
	}

	public GameObject contentPrefab;

	[SerializeField]private UIDragDropContainer tableContainer;
	[SerializeField]private UIGrid reminderTable;
	[SerializeField]private UIGrid conclusionTable;
	[SerializeField]private UIGrid truthTable;
	[SerializeField]private UILabel analyzeResultLabel;
	[SerializeField]private List<ContentLine> contentSlots;
	[SerializeField]private AnalyzeSystemGridController brainGridController;

	[SerializeField]private const float UPDATE_TIME = 1f;

	private List<int> variablesToCheck;

	private ContentType currentType;

	void Awake ()
	{
		if (instance == null)
			instance = this;
		else if (instance != this)
			DestroyImmediate(gameObject);
		DontDestroyOnLoad(gameObject);
		Initialize();
		UnlockNewContent(ContentType.Reminder, Consts.FileName.reminders, 0);
		UnlockNewContent(ContentType.Reminder, Consts.FileName.reminders, 1);
	}

	void Start ()
	{
		StartCoroutine(ContentUpdate());
	}

	void OnEnable ()
	{
		StopAllCoroutines();
		StartCoroutine(ContentUpdate());
	}

	void OnDisable ()
	{
		StopAllCoroutines();
	}

	private void Initialize ()
    {
		InitializeVariables();
		//Currently This return serves as preventing from reading the files since they are still unavailable!
		return;
		InitializeContents(ContentType.Reminder, Consts.VariableName.reminderState, Consts.FileName.reminders, Consts.Constants.REMINDER_NUM);
		InitializeContents(ContentType.Conclusion, Consts.VariableName.conclusionState, Consts.FileName.conclusions, Consts.Constants.CONCLUSION_NUM);
		InitializeContents(ContentType.Truth, Consts.VariableName.truthState, Consts.FileName.truths, Consts.Constants.TRUTH_NUM);
    }

	private void InitializeVariables ()
	{
		instance.contentSlots.Clear();
		currentType = ContentType.Reminder;
		variablesToCheck = new List<int>();
	}

	private void InitializeContents (ContentType type, string variableName, string targetFileName, int number)
	{
		for (int i = 0; i < number; i++)
		{
			if (DialogueLua.GetVariable(variableName + i).AsBool)
				UnlockNewContent(type, targetFileName, i);
			else if (type == ContentType.Reminder)
				variablesToCheck.Add(i);
		}
	}

	public static void UnlockNewContent (ContentType type, string targetFileName, int number)
	{
		string contentText = InfoSaver.GetStringFromResource(targetFileName, number);
		//!!!!!!UNSAFE coding way. Please make sure that the targetFile is absolutely correct!!!!!!
		string[] lineComponents = contentText.Split('#');
		int index = number;
		string title = lineComponents[0];
		string content = lineComponents[1];
		int higher = ((type == ContentType.Truth) ? -1 : int.Parse (lineComponents[2]));
		int another = ((type == ContentType.Truth) ? -1 : int.Parse (lineComponents[3]));
		int another2 = ((type == ContentType.Truth) ? -1 : int.Parse (lineComponents[4]));
		Content newContentEntry = new Content(type, title, content, index, another, another2, higher);
		//To be CONTINUED : WRITE A NEW CONTENT CLASS AND IMPLEMENT ITS INITIALIZER, THEN ADD IT HERE!!!!
		UIGrid targetTable = null;
		switch (type)
		{
			case ContentType.Reminder:
				targetTable = instance.reminderTable;
				break;
			case ContentType.Conclusion:
				targetTable = instance.conclusionTable;
				break;
			case ContentType.Truth:
				targetTable = instance.truthTable;
				break;
			default:
				break;
		}
		GameObject targetContent = NGUITools.AddChild(targetTable.gameObject, instance.contentPrefab);
		ContentLine targetLine = targetContent.GetComponent<ContentLine>();
		targetLine.Initialize(newContentEntry);
	}

	//Please do not leave malicious comments on this part ... after all this is the by-product of the DialogueLua Environment!
	//(I WILL NEVER USE THIS SYSTEM AGAIN!)
	//Acturally only update REMINDERS. Conclusions and truths could not be received directly. 
	private IEnumerator ContentUpdate()
	{
		while (true)
		{
			foreach (int varName in variablesToCheck)
			{
				if (DialogueLua.GetVariable(Consts.VariableName.reminderState + varName).AsBool)
				{
					variablesToCheck.Remove(varName);
					UnlockNewContent(ContentType.Reminder, Consts.FileName.reminders, varName);
					InfoSaver.SaveLuaEnvironment();
				}
			}
			yield return UPDATE_TIME;
		}
	}

	//An animation is expected here to enhace gamer experience. Just for test currently.
	public static void AnalyzeContent ()
	{
		int count = instance.contentSlots.Count;
		if (count == 0)
		{
			instance.PlayAnalyzeEffect(AnalyzeResult.Empty);
		}
		else if (count == 1)
		{
			instance.PlayAnalyzeEffect(AnalyzeResult.NeedMore);
		}
		else if (count == 2)
		{
			ContentLine c1 = instance.contentSlots[0];
			ContentLine c2 = instance.contentSlots[1];
			if (c1.content.another == c2.content.index)
			{
				if (c1.content.another2 == -1)
				{
					instance.PlayAnalyzeEffect(AnalyzeResult.Success);
				}
				else
				{
					instance.PlayAnalyzeEffect(AnalyzeResult.NeedMore);
				}
			}
			else
			{
				instance.PlayAnalyzeEffect(AnalyzeResult.Irrelevant);
			}
		}
		else if (count == 3)
		{
			ContentLine c1 = instance.contentSlots[0];
			ContentLine c2 = instance.contentSlots[1];
			ContentLine c3 = instance.contentSlots[2];
			//Enumerate all the possiblilities and then go on to check.
			if (c1.content.another == c2.content.index || c1.content.another2 == c2.content.index)
			{
				if (c1.content.another == c3.content.index || c1.content.another2 == c3.content.index)
				{
					instance.PlayAnalyzeEffect(AnalyzeResult.Success);
				}
				else if (c1.content.another2 == -1)
				{
					instance.PlayAnalyzeEffect(AnalyzeResult.Contradictive);
				}
				else
				{
					instance.PlayAnalyzeEffect(AnalyzeResult.Irrelevant);
				}
			}
			else if (c2.content.another == c3.content.index || c2.content.another2 == c2.content.index)
			{
				if (c2.content.another == c1.content.index || c2.content.another2 == c1.content.index)
				{
					instance.PlayAnalyzeEffect(AnalyzeResult.Success);
				}
				else if (c2.content.another2 == -1)
				{
					instance.PlayAnalyzeEffect(AnalyzeResult.Contradictive);
				}
				else
				{
					instance.PlayAnalyzeEffect(AnalyzeResult.Irrelevant);
				}
			}
			else if (c3.content.another == c1.content.index || c3.content.another2 == c1.content.index)
			{
				if (c3.content.another == c2.content.index || c3.content.another2 == c2.content.index)
				{
					instance.PlayAnalyzeEffect(AnalyzeResult.Success);
					return;
				}
				else if (c3.content.another2 == -1)
				{
					instance.PlayAnalyzeEffect(AnalyzeResult.Contradictive);
				}
				else
				{
					instance.PlayAnalyzeEffect(AnalyzeResult.Irrelevant);
				}
			}
			else
			{
				instance.PlayAnalyzeEffect(AnalyzeResult.Irrelevant);
			}
		}
	}

	//NGUI doesn't support user-defined variable types ... Hence ... as you can see!
	public void SwitchToReminder ()
	{
		if (currentType == ContentType.Reminder)
			return;
		SwitchTable(ContentType.Reminder);
	}

	public void SwitchToConclusion ()
	{
		if (currentType == ContentType.Conclusion)
			return;
		SwitchTable(ContentType.Conclusion);
	}

	public void SwitchToTruth ()
	{
		if (currentType == ContentType.Truth)
			return;
		SwitchTable(ContentType.Truth);
	}

	private void PlayAnalyzeEffect (AnalyzeResult result)
	{
		SetAnalyzeResultLabel(result);
		//Play the corresponding animation; Delete the gameObjects, 
		if (result == AnalyzeResult.Success)
		{
			ContentType type = (contentSlots[0].content.type == ContentType.Reminder) ? ContentType.Conclusion : ContentType.Truth;
			string fileName = (contentSlots[0].content.type == ContentType.Reminder) ? Consts.FileName.conclusions : Consts.FileName.truths;
			UnlockNewContent(type, fileName, contentSlots[0].content.higher);
			foreach (ContentLine content in contentSlots)
			{
				Destroy(content.gameObject);
			}
			contentSlots.Clear();
		}
		//However if the result is an empty state ... simply ignore it!
		else if(result != AnalyzeResult.Empty)
		{
			
		}
	}

	public static void SwitchTable (ContentType type)
	{
		foreach (ContentLine content in instance.contentSlots)
		{
			content.transform.parent = GetCurrentGrid().transform;
		}
		GetCurrentGrid().Reposition();
		instance.reminderTable.gameObject.SetActive(false);
		instance.conclusionTable.gameObject.SetActive(false);
		instance.truthTable.gameObject.SetActive(false);
		UITooltip.Hide();
		switch (type)
		{
			case ContentType.Reminder:
				instance.reminderTable.gameObject.SetActive(true);
				instance.tableContainer.reparentTarget = instance.reminderTable.transform;
				break;
			case ContentType.Conclusion:
				instance.conclusionTable.gameObject.SetActive(true);
				instance.tableContainer.reparentTarget = instance.conclusionTable.transform;
				break;
			case ContentType.Truth:
				instance.truthTable.gameObject.SetActive(true);
				instance.tableContainer.reparentTarget = instance.truthTable.transform;
				break;
			default:
				break;
		}
		instance.currentType = type;
		instance.contentSlots.Clear();
	}

	public static UIGrid GetCurrentGrid ()
	{
		switch (instance.currentType)
		{
			case ContentType.Reminder:
				return instance.reminderTable;
				break;
			case ContentType.Conclusion:
				return instance.conclusionTable;
				break;
			case ContentType.Truth:
				return instance.truthTable;
				break;
			default:
				break;
		}
		return null;
	}

	public static void FillSlots (List<ContentLine> contentList)
	{
		instance.contentSlots.Clear();
		instance.contentSlots = contentList;
	}

	private void SetAnalyzeResultLabel(AnalyzeResult result)
	{
		int x = (int)result;
		instance.analyzeResultLabel.text = Consts.AnalyzeResults[x];
	}
}
